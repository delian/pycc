Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> functions
Rule 2     program -> glob_variables ; functions
Rule 3     glob_variables -> glob_variable
Rule 4     glob_variables -> glob_variables ; glob_variable
Rule 5     glob_variable -> NAME = expression
Rule 6     functions -> function
Rule 7     functions -> functions ; function
Rule 8     function -> NAME ( ) block
Rule 9     block -> { statements }
Rule 10    block -> { statements ; }
Rule 11    block -> { }
Rule 12    statements -> statement
Rule 13    statements -> statements ; statement
Rule 14    statement -> var_declare
Rule 15    statement -> var_assign
Rule 16    statement -> function_call
Rule 17    statement -> expression
Rule 18    var_declare -> LET NAME
Rule 19    var_declare -> LET NAME = expression
Rule 20    var_assign -> NAME = expression
Rule 21    function_call -> NAME ( )
Rule 22    expression -> expression + term
Rule 23    expression -> expression - term
Rule 24    expression -> expression + function_call
Rule 25    expression -> expression - function_call
Rule 26    term -> term * factor
Rule 27    term -> term / factor
Rule 28    term -> term * function_call
Rule 29    term -> term / function_call
Rule 30    expression -> term
Rule 31    term -> factor
Rule 32    factor -> NUMBER
Rule 33    factor -> NAME
Rule 34    factor -> ( expression )

Terminals, with rules where they appear

(                    : 8 21 34
)                    : 8 21 34
*                    : 26 28
+                    : 22 24
-                    : 23 25
/                    : 27 29
;                    : 2 4 7 10 13
=                    : 5 19 20
LET                  : 18 19
NAME                 : 5 8 18 19 20 21 33
NUMBER               : 32
error                : 
{                    : 9 10 11
}                    : 9 10 11

Nonterminals, with rules where they appear

block                : 8
expression           : 5 17 19 20 22 23 24 25 34
factor               : 26 27 31
function             : 6 7
function_call        : 16 24 25 28 29
functions            : 1 2 7
glob_variable        : 3 4
glob_variables       : 2 4
program              : 0
statement            : 12 13
statements           : 9 10 13
term                 : 22 23 26 27 28 29 30
var_assign           : 15
var_declare          : 14

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . functions
    (2) program -> . glob_variables ; functions
    (6) functions -> . function
    (7) functions -> . functions ; function
    (3) glob_variables -> . glob_variable
    (4) glob_variables -> . glob_variables ; glob_variable
    (8) function -> . NAME ( ) block
    (5) glob_variable -> . NAME = expression

    NAME            shift and go to state 6

    program                        shift and go to state 1
    functions                      shift and go to state 2
    glob_variables                 shift and go to state 3
    function                       shift and go to state 4
    glob_variable                  shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> functions .
    (7) functions -> functions . ; function

    $end            reduce using rule 1 (program -> functions .)
    ;               shift and go to state 7


state 3

    (2) program -> glob_variables . ; functions
    (4) glob_variables -> glob_variables . ; glob_variable

    ;               shift and go to state 8


state 4

    (6) functions -> function .

    ;               reduce using rule 6 (functions -> function .)
    $end            reduce using rule 6 (functions -> function .)


state 5

    (3) glob_variables -> glob_variable .

    ;               reduce using rule 3 (glob_variables -> glob_variable .)


state 6

    (8) function -> NAME . ( ) block
    (5) glob_variable -> NAME . = expression

    (               shift and go to state 9
    =               shift and go to state 10


state 7

    (7) functions -> functions ; . function
    (8) function -> . NAME ( ) block

    NAME            shift and go to state 12

    function                       shift and go to state 11

state 8

    (2) program -> glob_variables ; . functions
    (4) glob_variables -> glob_variables ; . glob_variable
    (6) functions -> . function
    (7) functions -> . functions ; function
    (5) glob_variable -> . NAME = expression
    (8) function -> . NAME ( ) block

    NAME            shift and go to state 15

    functions                      shift and go to state 13
    glob_variable                  shift and go to state 14
    function                       shift and go to state 4

state 9

    (8) function -> NAME ( . ) block

    )               shift and go to state 16


state 10

    (5) glob_variable -> NAME = . expression
    (22) expression -> . expression + term
    (23) expression -> . expression - term
    (24) expression -> . expression + function_call
    (25) expression -> . expression - function_call
    (30) expression -> . term
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 18
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 11

    (7) functions -> functions ; function .

    ;               reduce using rule 7 (functions -> functions ; function .)
    $end            reduce using rule 7 (functions -> functions ; function .)


state 12

    (8) function -> NAME . ( ) block

    (               shift and go to state 9


state 13

    (2) program -> glob_variables ; functions .
    (7) functions -> functions . ; function

    $end            reduce using rule 2 (program -> glob_variables ; functions .)
    ;               shift and go to state 7


state 14

    (4) glob_variables -> glob_variables ; glob_variable .

    ;               reduce using rule 4 (glob_variables -> glob_variables ; glob_variable .)


state 15

    (5) glob_variable -> NAME . = expression
    (8) function -> NAME . ( ) block

    =               shift and go to state 10
    (               shift and go to state 9


state 16

    (8) function -> NAME ( ) . block
    (9) block -> . { statements }
    (10) block -> . { statements ; }
    (11) block -> . { }

    {               shift and go to state 24

    block                          shift and go to state 23

state 17

    (33) factor -> NAME .

    *               reduce using rule 33 (factor -> NAME .)
    /               reduce using rule 33 (factor -> NAME .)
    +               reduce using rule 33 (factor -> NAME .)
    -               reduce using rule 33 (factor -> NAME .)
    ;               reduce using rule 33 (factor -> NAME .)
    )               reduce using rule 33 (factor -> NAME .)
    }               reduce using rule 33 (factor -> NAME .)


state 18

    (5) glob_variable -> NAME = expression .
    (22) expression -> expression . + term
    (23) expression -> expression . - term
    (24) expression -> expression . + function_call
    (25) expression -> expression . - function_call

    ;               reduce using rule 5 (glob_variable -> NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 19

    (30) expression -> term .
    (26) term -> term . * factor
    (27) term -> term . / factor
    (28) term -> term . * function_call
    (29) term -> term . / function_call

    +               reduce using rule 30 (expression -> term .)
    -               reduce using rule 30 (expression -> term .)
    ;               reduce using rule 30 (expression -> term .)
    )               reduce using rule 30 (expression -> term .)
    }               reduce using rule 30 (expression -> term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 20

    (31) term -> factor .

    *               reduce using rule 31 (term -> factor .)
    /               reduce using rule 31 (term -> factor .)
    +               reduce using rule 31 (term -> factor .)
    -               reduce using rule 31 (term -> factor .)
    ;               reduce using rule 31 (term -> factor .)
    )               reduce using rule 31 (term -> factor .)
    }               reduce using rule 31 (term -> factor .)


state 21

    (32) factor -> NUMBER .

    *               reduce using rule 32 (factor -> NUMBER .)
    /               reduce using rule 32 (factor -> NUMBER .)
    +               reduce using rule 32 (factor -> NUMBER .)
    -               reduce using rule 32 (factor -> NUMBER .)
    ;               reduce using rule 32 (factor -> NUMBER .)
    )               reduce using rule 32 (factor -> NUMBER .)
    }               reduce using rule 32 (factor -> NUMBER .)


state 22

    (34) factor -> ( . expression )
    (22) expression -> . expression + term
    (23) expression -> . expression - term
    (24) expression -> . expression + function_call
    (25) expression -> . expression - function_call
    (30) expression -> . term
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 29
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 23

    (8) function -> NAME ( ) block .

    ;               reduce using rule 8 (function -> NAME ( ) block .)
    $end            reduce using rule 8 (function -> NAME ( ) block .)


state 24

    (9) block -> { . statements }
    (10) block -> { . statements ; }
    (11) block -> { . }
    (12) statements -> . statement
    (13) statements -> . statements ; statement
    (14) statement -> . var_declare
    (15) statement -> . var_assign
    (16) statement -> . function_call
    (17) statement -> . expression
    (18) var_declare -> . LET NAME
    (19) var_declare -> . LET NAME = expression
    (20) var_assign -> . NAME = expression
    (21) function_call -> . NAME ( )
    (22) expression -> . expression + term
    (23) expression -> . expression - term
    (24) expression -> . expression + function_call
    (25) expression -> . expression - function_call
    (30) expression -> . term
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    }               shift and go to state 31
    LET             shift and go to state 37
    NAME            shift and go to state 38
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    statements                     shift and go to state 30
    statement                      shift and go to state 32
    var_declare                    shift and go to state 33
    var_assign                     shift and go to state 34
    function_call                  shift and go to state 35
    expression                     shift and go to state 36
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 25

    (22) expression -> expression + . term
    (24) expression -> expression + . function_call
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (21) function_call -> . NAME ( )
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    NAME            shift and go to state 41
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    term                           shift and go to state 39
    function_call                  shift and go to state 40
    factor                         shift and go to state 20

state 26

    (23) expression -> expression - . term
    (25) expression -> expression - . function_call
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (21) function_call -> . NAME ( )
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    NAME            shift and go to state 41
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    term                           shift and go to state 42
    function_call                  shift and go to state 43
    factor                         shift and go to state 20

state 27

    (26) term -> term * . factor
    (28) term -> term * . function_call
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )
    (21) function_call -> . NAME ( )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 46
    (               shift and go to state 22

    factor                         shift and go to state 44
    function_call                  shift and go to state 45

state 28

    (27) term -> term / . factor
    (29) term -> term / . function_call
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )
    (21) function_call -> . NAME ( )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 46
    (               shift and go to state 22

    factor                         shift and go to state 47
    function_call                  shift and go to state 48

state 29

    (34) factor -> ( expression . )
    (22) expression -> expression . + term
    (23) expression -> expression . - term
    (24) expression -> expression . + function_call
    (25) expression -> expression . - function_call

    )               shift and go to state 49
    +               shift and go to state 25
    -               shift and go to state 26


state 30

    (9) block -> { statements . }
    (10) block -> { statements . ; }
    (13) statements -> statements . ; statement

    }               shift and go to state 50
    ;               shift and go to state 51


state 31

    (11) block -> { } .

    ;               reduce using rule 11 (block -> { } .)
    $end            reduce using rule 11 (block -> { } .)


state 32

    (12) statements -> statement .

    }               reduce using rule 12 (statements -> statement .)
    ;               reduce using rule 12 (statements -> statement .)


state 33

    (14) statement -> var_declare .

    }               reduce using rule 14 (statement -> var_declare .)
    ;               reduce using rule 14 (statement -> var_declare .)


state 34

    (15) statement -> var_assign .

    }               reduce using rule 15 (statement -> var_assign .)
    ;               reduce using rule 15 (statement -> var_assign .)


state 35

    (16) statement -> function_call .

    }               reduce using rule 16 (statement -> function_call .)
    ;               reduce using rule 16 (statement -> function_call .)


state 36

    (17) statement -> expression .
    (22) expression -> expression . + term
    (23) expression -> expression . - term
    (24) expression -> expression . + function_call
    (25) expression -> expression . - function_call

    }               reduce using rule 17 (statement -> expression .)
    ;               reduce using rule 17 (statement -> expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 37

    (18) var_declare -> LET . NAME
    (19) var_declare -> LET . NAME = expression

    NAME            shift and go to state 52


state 38

    (20) var_assign -> NAME . = expression
    (21) function_call -> NAME . ( )
    (33) factor -> NAME .

    =               shift and go to state 53
    (               shift and go to state 54
    *               reduce using rule 33 (factor -> NAME .)
    /               reduce using rule 33 (factor -> NAME .)
    +               reduce using rule 33 (factor -> NAME .)
    -               reduce using rule 33 (factor -> NAME .)
    }               reduce using rule 33 (factor -> NAME .)
    ;               reduce using rule 33 (factor -> NAME .)


state 39

    (22) expression -> expression + term .
    (26) term -> term . * factor
    (27) term -> term . / factor
    (28) term -> term . * function_call
    (29) term -> term . / function_call

    +               reduce using rule 22 (expression -> expression + term .)
    -               reduce using rule 22 (expression -> expression + term .)
    ;               reduce using rule 22 (expression -> expression + term .)
    )               reduce using rule 22 (expression -> expression + term .)
    }               reduce using rule 22 (expression -> expression + term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 40

    (24) expression -> expression + function_call .

    +               reduce using rule 24 (expression -> expression + function_call .)
    -               reduce using rule 24 (expression -> expression + function_call .)
    ;               reduce using rule 24 (expression -> expression + function_call .)
    )               reduce using rule 24 (expression -> expression + function_call .)
    }               reduce using rule 24 (expression -> expression + function_call .)


state 41

    (21) function_call -> NAME . ( )
    (33) factor -> NAME .

    (               shift and go to state 54
    *               reduce using rule 33 (factor -> NAME .)
    /               reduce using rule 33 (factor -> NAME .)
    +               reduce using rule 33 (factor -> NAME .)
    -               reduce using rule 33 (factor -> NAME .)
    ;               reduce using rule 33 (factor -> NAME .)
    )               reduce using rule 33 (factor -> NAME .)
    }               reduce using rule 33 (factor -> NAME .)


state 42

    (23) expression -> expression - term .
    (26) term -> term . * factor
    (27) term -> term . / factor
    (28) term -> term . * function_call
    (29) term -> term . / function_call

    +               reduce using rule 23 (expression -> expression - term .)
    -               reduce using rule 23 (expression -> expression - term .)
    ;               reduce using rule 23 (expression -> expression - term .)
    )               reduce using rule 23 (expression -> expression - term .)
    }               reduce using rule 23 (expression -> expression - term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 43

    (25) expression -> expression - function_call .

    +               reduce using rule 25 (expression -> expression - function_call .)
    -               reduce using rule 25 (expression -> expression - function_call .)
    ;               reduce using rule 25 (expression -> expression - function_call .)
    )               reduce using rule 25 (expression -> expression - function_call .)
    }               reduce using rule 25 (expression -> expression - function_call .)


state 44

    (26) term -> term * factor .

    *               reduce using rule 26 (term -> term * factor .)
    /               reduce using rule 26 (term -> term * factor .)
    +               reduce using rule 26 (term -> term * factor .)
    -               reduce using rule 26 (term -> term * factor .)
    ;               reduce using rule 26 (term -> term * factor .)
    )               reduce using rule 26 (term -> term * factor .)
    }               reduce using rule 26 (term -> term * factor .)


state 45

    (28) term -> term * function_call .

    *               reduce using rule 28 (term -> term * function_call .)
    /               reduce using rule 28 (term -> term * function_call .)
    +               reduce using rule 28 (term -> term * function_call .)
    -               reduce using rule 28 (term -> term * function_call .)
    ;               reduce using rule 28 (term -> term * function_call .)
    )               reduce using rule 28 (term -> term * function_call .)
    }               reduce using rule 28 (term -> term * function_call .)


state 46

    (33) factor -> NAME .
    (21) function_call -> NAME . ( )

    *               reduce using rule 33 (factor -> NAME .)
    /               reduce using rule 33 (factor -> NAME .)
    +               reduce using rule 33 (factor -> NAME .)
    -               reduce using rule 33 (factor -> NAME .)
    ;               reduce using rule 33 (factor -> NAME .)
    )               reduce using rule 33 (factor -> NAME .)
    }               reduce using rule 33 (factor -> NAME .)
    (               shift and go to state 54


state 47

    (27) term -> term / factor .

    *               reduce using rule 27 (term -> term / factor .)
    /               reduce using rule 27 (term -> term / factor .)
    +               reduce using rule 27 (term -> term / factor .)
    -               reduce using rule 27 (term -> term / factor .)
    ;               reduce using rule 27 (term -> term / factor .)
    )               reduce using rule 27 (term -> term / factor .)
    }               reduce using rule 27 (term -> term / factor .)


state 48

    (29) term -> term / function_call .

    *               reduce using rule 29 (term -> term / function_call .)
    /               reduce using rule 29 (term -> term / function_call .)
    +               reduce using rule 29 (term -> term / function_call .)
    -               reduce using rule 29 (term -> term / function_call .)
    ;               reduce using rule 29 (term -> term / function_call .)
    )               reduce using rule 29 (term -> term / function_call .)
    }               reduce using rule 29 (term -> term / function_call .)


state 49

    (34) factor -> ( expression ) .

    *               reduce using rule 34 (factor -> ( expression ) .)
    /               reduce using rule 34 (factor -> ( expression ) .)
    +               reduce using rule 34 (factor -> ( expression ) .)
    -               reduce using rule 34 (factor -> ( expression ) .)
    ;               reduce using rule 34 (factor -> ( expression ) .)
    )               reduce using rule 34 (factor -> ( expression ) .)
    }               reduce using rule 34 (factor -> ( expression ) .)


state 50

    (9) block -> { statements } .

    ;               reduce using rule 9 (block -> { statements } .)
    $end            reduce using rule 9 (block -> { statements } .)


state 51

    (10) block -> { statements ; . }
    (13) statements -> statements ; . statement
    (14) statement -> . var_declare
    (15) statement -> . var_assign
    (16) statement -> . function_call
    (17) statement -> . expression
    (18) var_declare -> . LET NAME
    (19) var_declare -> . LET NAME = expression
    (20) var_assign -> . NAME = expression
    (21) function_call -> . NAME ( )
    (22) expression -> . expression + term
    (23) expression -> . expression - term
    (24) expression -> . expression + function_call
    (25) expression -> . expression - function_call
    (30) expression -> . term
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    }               shift and go to state 55
    LET             shift and go to state 37
    NAME            shift and go to state 38
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    statement                      shift and go to state 56
    var_declare                    shift and go to state 33
    var_assign                     shift and go to state 34
    function_call                  shift and go to state 35
    expression                     shift and go to state 36
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 52

    (18) var_declare -> LET NAME .
    (19) var_declare -> LET NAME . = expression

    }               reduce using rule 18 (var_declare -> LET NAME .)
    ;               reduce using rule 18 (var_declare -> LET NAME .)
    =               shift and go to state 57


state 53

    (20) var_assign -> NAME = . expression
    (22) expression -> . expression + term
    (23) expression -> . expression - term
    (24) expression -> . expression + function_call
    (25) expression -> . expression - function_call
    (30) expression -> . term
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 58
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 54

    (21) function_call -> NAME ( . )

    )               shift and go to state 59


state 55

    (10) block -> { statements ; } .

    ;               reduce using rule 10 (block -> { statements ; } .)
    $end            reduce using rule 10 (block -> { statements ; } .)


state 56

    (13) statements -> statements ; statement .

    }               reduce using rule 13 (statements -> statements ; statement .)
    ;               reduce using rule 13 (statements -> statements ; statement .)


state 57

    (19) var_declare -> LET NAME = . expression
    (22) expression -> . expression + term
    (23) expression -> . expression - term
    (24) expression -> . expression + function_call
    (25) expression -> . expression - function_call
    (30) expression -> . term
    (26) term -> . term * factor
    (27) term -> . term / factor
    (28) term -> . term * function_call
    (29) term -> . term / function_call
    (31) term -> . factor
    (32) factor -> . NUMBER
    (33) factor -> . NAME
    (34) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 60
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 58

    (20) var_assign -> NAME = expression .
    (22) expression -> expression . + term
    (23) expression -> expression . - term
    (24) expression -> expression . + function_call
    (25) expression -> expression . - function_call

    }               reduce using rule 20 (var_assign -> NAME = expression .)
    ;               reduce using rule 20 (var_assign -> NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 59

    (21) function_call -> NAME ( ) .

    }               reduce using rule 21 (function_call -> NAME ( ) .)
    ;               reduce using rule 21 (function_call -> NAME ( ) .)
    +               reduce using rule 21 (function_call -> NAME ( ) .)
    -               reduce using rule 21 (function_call -> NAME ( ) .)
    )               reduce using rule 21 (function_call -> NAME ( ) .)
    *               reduce using rule 21 (function_call -> NAME ( ) .)
    /               reduce using rule 21 (function_call -> NAME ( ) .)


state 60

    (19) var_declare -> LET NAME = expression .
    (22) expression -> expression . + term
    (23) expression -> expression . - term
    (24) expression -> expression . + function_call
    (25) expression -> expression . - function_call

    }               reduce using rule 19 (var_declare -> LET NAME = expression .)
    ;               reduce using rule 19 (var_declare -> LET NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26

