Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> functions
Rule 2     program -> glob_variables ; functions
Rule 3     glob_variables -> glob_variable
Rule 4     glob_variables -> glob_variables ; glob_variable
Rule 5     glob_variable -> NAME = expression
Rule 6     functions -> function
Rule 7     functions -> functions ; function
Rule 8     function -> NAME ( ) block
Rule 9     block -> { statements }
Rule 10    block -> { statements ; }
Rule 11    block -> { }
Rule 12    statements -> statement
Rule 13    statements -> statements ; statement
Rule 14    statement -> expression
Rule 15    statement -> var_assign
Rule 16    var_assign -> NAME = expression
Rule 17    expression -> expression + term
Rule 18    expression -> expression - term
Rule 19    term -> term * factor
Rule 20    term -> term / factor
Rule 21    expression -> term
Rule 22    term -> factor
Rule 23    factor -> NUMBER
Rule 24    factor -> NAME
Rule 25    factor -> ( expression )

Terminals, with rules where they appear

(                    : 8 25
)                    : 8 25
*                    : 19
+                    : 17
-                    : 18
/                    : 20
;                    : 2 4 7 10 13
=                    : 5 16
NAME                 : 5 8 16 24
NUMBER               : 23
error                : 
{                    : 9 10 11
}                    : 9 10 11

Nonterminals, with rules where they appear

block                : 8
expression           : 5 14 16 17 18 25
factor               : 19 20 22
function             : 6 7
functions            : 1 2 7
glob_variable        : 3 4
glob_variables       : 2 4
program              : 0
statement            : 12 13
statements           : 9 10 13
term                 : 17 18 19 20 21
var_assign           : 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . functions
    (2) program -> . glob_variables ; functions
    (6) functions -> . function
    (7) functions -> . functions ; function
    (3) glob_variables -> . glob_variable
    (4) glob_variables -> . glob_variables ; glob_variable
    (8) function -> . NAME ( ) block
    (5) glob_variable -> . NAME = expression

    NAME            shift and go to state 6

    program                        shift and go to state 1
    functions                      shift and go to state 2
    glob_variables                 shift and go to state 3
    function                       shift and go to state 4
    glob_variable                  shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> functions .
    (7) functions -> functions . ; function

    $end            reduce using rule 1 (program -> functions .)
    ;               shift and go to state 7


state 3

    (2) program -> glob_variables . ; functions
    (4) glob_variables -> glob_variables . ; glob_variable

    ;               shift and go to state 8


state 4

    (6) functions -> function .

    ;               reduce using rule 6 (functions -> function .)
    $end            reduce using rule 6 (functions -> function .)


state 5

    (3) glob_variables -> glob_variable .

    ;               reduce using rule 3 (glob_variables -> glob_variable .)


state 6

    (8) function -> NAME . ( ) block
    (5) glob_variable -> NAME . = expression

    (               shift and go to state 9
    =               shift and go to state 10


state 7

    (7) functions -> functions ; . function
    (8) function -> . NAME ( ) block

    NAME            shift and go to state 12

    function                       shift and go to state 11

state 8

    (2) program -> glob_variables ; . functions
    (4) glob_variables -> glob_variables ; . glob_variable
    (6) functions -> . function
    (7) functions -> . functions ; function
    (5) glob_variable -> . NAME = expression
    (8) function -> . NAME ( ) block

    NAME            shift and go to state 15

    functions                      shift and go to state 13
    glob_variable                  shift and go to state 14
    function                       shift and go to state 4

state 9

    (8) function -> NAME ( . ) block

    )               shift and go to state 16


state 10

    (5) glob_variable -> NAME = . expression
    (17) expression -> . expression + term
    (18) expression -> . expression - term
    (21) expression -> . term
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 18
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 11

    (7) functions -> functions ; function .

    ;               reduce using rule 7 (functions -> functions ; function .)
    $end            reduce using rule 7 (functions -> functions ; function .)


state 12

    (8) function -> NAME . ( ) block

    (               shift and go to state 9


state 13

    (2) program -> glob_variables ; functions .
    (7) functions -> functions . ; function

    $end            reduce using rule 2 (program -> glob_variables ; functions .)
    ;               shift and go to state 7


state 14

    (4) glob_variables -> glob_variables ; glob_variable .

    ;               reduce using rule 4 (glob_variables -> glob_variables ; glob_variable .)


state 15

    (5) glob_variable -> NAME . = expression
    (8) function -> NAME . ( ) block

    =               shift and go to state 10
    (               shift and go to state 9


state 16

    (8) function -> NAME ( ) . block
    (9) block -> . { statements }
    (10) block -> . { statements ; }
    (11) block -> . { }

    {               shift and go to state 24

    block                          shift and go to state 23

state 17

    (24) factor -> NAME .

    *               reduce using rule 24 (factor -> NAME .)
    /               reduce using rule 24 (factor -> NAME .)
    +               reduce using rule 24 (factor -> NAME .)
    -               reduce using rule 24 (factor -> NAME .)
    ;               reduce using rule 24 (factor -> NAME .)
    )               reduce using rule 24 (factor -> NAME .)
    }               reduce using rule 24 (factor -> NAME .)


state 18

    (5) glob_variable -> NAME = expression .
    (17) expression -> expression . + term
    (18) expression -> expression . - term

    ;               reduce using rule 5 (glob_variable -> NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 19

    (21) expression -> term .
    (19) term -> term . * factor
    (20) term -> term . / factor

    +               reduce using rule 21 (expression -> term .)
    -               reduce using rule 21 (expression -> term .)
    ;               reduce using rule 21 (expression -> term .)
    )               reduce using rule 21 (expression -> term .)
    }               reduce using rule 21 (expression -> term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 20

    (22) term -> factor .

    *               reduce using rule 22 (term -> factor .)
    /               reduce using rule 22 (term -> factor .)
    +               reduce using rule 22 (term -> factor .)
    -               reduce using rule 22 (term -> factor .)
    ;               reduce using rule 22 (term -> factor .)
    )               reduce using rule 22 (term -> factor .)
    }               reduce using rule 22 (term -> factor .)


state 21

    (23) factor -> NUMBER .

    *               reduce using rule 23 (factor -> NUMBER .)
    /               reduce using rule 23 (factor -> NUMBER .)
    +               reduce using rule 23 (factor -> NUMBER .)
    -               reduce using rule 23 (factor -> NUMBER .)
    ;               reduce using rule 23 (factor -> NUMBER .)
    )               reduce using rule 23 (factor -> NUMBER .)
    }               reduce using rule 23 (factor -> NUMBER .)


state 22

    (25) factor -> ( . expression )
    (17) expression -> . expression + term
    (18) expression -> . expression - term
    (21) expression -> . term
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 29
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 23

    (8) function -> NAME ( ) block .

    ;               reduce using rule 8 (function -> NAME ( ) block .)
    $end            reduce using rule 8 (function -> NAME ( ) block .)


state 24

    (9) block -> { . statements }
    (10) block -> { . statements ; }
    (11) block -> { . }
    (12) statements -> . statement
    (13) statements -> . statements ; statement
    (14) statement -> . expression
    (15) statement -> . var_assign
    (17) expression -> . expression + term
    (18) expression -> . expression - term
    (21) expression -> . term
    (16) var_assign -> . NAME = expression
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    }               shift and go to state 31
    NAME            shift and go to state 35
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    statements                     shift and go to state 30
    statement                      shift and go to state 32
    expression                     shift and go to state 33
    var_assign                     shift and go to state 34
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 25

    (17) expression -> expression + . term
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    term                           shift and go to state 36
    factor                         shift and go to state 20

state 26

    (18) expression -> expression - . term
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    term                           shift and go to state 37
    factor                         shift and go to state 20

state 27

    (19) term -> term * . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    factor                         shift and go to state 38

state 28

    (20) term -> term / . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    factor                         shift and go to state 39

state 29

    (25) factor -> ( expression . )
    (17) expression -> expression . + term
    (18) expression -> expression . - term

    )               shift and go to state 40
    +               shift and go to state 25
    -               shift and go to state 26


state 30

    (9) block -> { statements . }
    (10) block -> { statements . ; }
    (13) statements -> statements . ; statement

    }               shift and go to state 41
    ;               shift and go to state 42


state 31

    (11) block -> { } .

    ;               reduce using rule 11 (block -> { } .)
    $end            reduce using rule 11 (block -> { } .)


state 32

    (12) statements -> statement .

    }               reduce using rule 12 (statements -> statement .)
    ;               reduce using rule 12 (statements -> statement .)


state 33

    (14) statement -> expression .
    (17) expression -> expression . + term
    (18) expression -> expression . - term

    }               reduce using rule 14 (statement -> expression .)
    ;               reduce using rule 14 (statement -> expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 34

    (15) statement -> var_assign .

    }               reduce using rule 15 (statement -> var_assign .)
    ;               reduce using rule 15 (statement -> var_assign .)


state 35

    (16) var_assign -> NAME . = expression
    (24) factor -> NAME .

    =               shift and go to state 43
    *               reduce using rule 24 (factor -> NAME .)
    /               reduce using rule 24 (factor -> NAME .)
    +               reduce using rule 24 (factor -> NAME .)
    -               reduce using rule 24 (factor -> NAME .)
    }               reduce using rule 24 (factor -> NAME .)
    ;               reduce using rule 24 (factor -> NAME .)


state 36

    (17) expression -> expression + term .
    (19) term -> term . * factor
    (20) term -> term . / factor

    +               reduce using rule 17 (expression -> expression + term .)
    -               reduce using rule 17 (expression -> expression + term .)
    ;               reduce using rule 17 (expression -> expression + term .)
    )               reduce using rule 17 (expression -> expression + term .)
    }               reduce using rule 17 (expression -> expression + term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 37

    (18) expression -> expression - term .
    (19) term -> term . * factor
    (20) term -> term . / factor

    +               reduce using rule 18 (expression -> expression - term .)
    -               reduce using rule 18 (expression -> expression - term .)
    ;               reduce using rule 18 (expression -> expression - term .)
    )               reduce using rule 18 (expression -> expression - term .)
    }               reduce using rule 18 (expression -> expression - term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 38

    (19) term -> term * factor .

    *               reduce using rule 19 (term -> term * factor .)
    /               reduce using rule 19 (term -> term * factor .)
    +               reduce using rule 19 (term -> term * factor .)
    -               reduce using rule 19 (term -> term * factor .)
    ;               reduce using rule 19 (term -> term * factor .)
    )               reduce using rule 19 (term -> term * factor .)
    }               reduce using rule 19 (term -> term * factor .)


state 39

    (20) term -> term / factor .

    *               reduce using rule 20 (term -> term / factor .)
    /               reduce using rule 20 (term -> term / factor .)
    +               reduce using rule 20 (term -> term / factor .)
    -               reduce using rule 20 (term -> term / factor .)
    ;               reduce using rule 20 (term -> term / factor .)
    )               reduce using rule 20 (term -> term / factor .)
    }               reduce using rule 20 (term -> term / factor .)


state 40

    (25) factor -> ( expression ) .

    *               reduce using rule 25 (factor -> ( expression ) .)
    /               reduce using rule 25 (factor -> ( expression ) .)
    +               reduce using rule 25 (factor -> ( expression ) .)
    -               reduce using rule 25 (factor -> ( expression ) .)
    ;               reduce using rule 25 (factor -> ( expression ) .)
    )               reduce using rule 25 (factor -> ( expression ) .)
    }               reduce using rule 25 (factor -> ( expression ) .)


state 41

    (9) block -> { statements } .

    ;               reduce using rule 9 (block -> { statements } .)
    $end            reduce using rule 9 (block -> { statements } .)


state 42

    (10) block -> { statements ; . }
    (13) statements -> statements ; . statement
    (14) statement -> . expression
    (15) statement -> . var_assign
    (17) expression -> . expression + term
    (18) expression -> . expression - term
    (21) expression -> . term
    (16) var_assign -> . NAME = expression
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    }               shift and go to state 44
    NAME            shift and go to state 35
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    statement                      shift and go to state 45
    expression                     shift and go to state 33
    var_assign                     shift and go to state 34
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 43

    (16) var_assign -> NAME = . expression
    (17) expression -> . expression + term
    (18) expression -> . expression - term
    (21) expression -> . term
    (19) term -> . term * factor
    (20) term -> . term / factor
    (22) term -> . factor
    (23) factor -> . NUMBER
    (24) factor -> . NAME
    (25) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 46
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 44

    (10) block -> { statements ; } .

    ;               reduce using rule 10 (block -> { statements ; } .)
    $end            reduce using rule 10 (block -> { statements ; } .)


state 45

    (13) statements -> statements ; statement .

    }               reduce using rule 13 (statements -> statements ; statement .)
    ;               reduce using rule 13 (statements -> statements ; statement .)


state 46

    (16) var_assign -> NAME = expression .
    (17) expression -> expression . + term
    (18) expression -> expression . - term

    }               reduce using rule 16 (var_assign -> NAME = expression .)
    ;               reduce using rule 16 (var_assign -> NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26

