Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> functions
Rule 2     program -> glob_variables ; functions
Rule 3     glob_variables -> glob_variable
Rule 4     glob_variables -> glob_variables ; glob_variable
Rule 5     glob_variable -> NAME = expression
Rule 6     functions -> function
Rule 7     functions -> functions ; function
Rule 8     function -> NAME ( ) block
Rule 9     block -> { statements }
Rule 10    block -> { statements ; }
Rule 11    block -> { }
Rule 12    statements -> statement
Rule 13    statements -> statements ; statement
Rule 14    statement -> expression
Rule 15    statement -> var_declare
Rule 16    statement -> var_assign
Rule 17    var_declare -> LET NAME
Rule 18    var_assign -> NAME = expression
Rule 19    function_call -> NAME ( )
Rule 20    expression -> expression + term
Rule 21    expression -> expression - term
Rule 22    expression -> expression + function_call
Rule 23    expression -> expression - function_call
Rule 24    term -> term * factor
Rule 25    term -> term / factor
Rule 26    term -> term * function_call
Rule 27    term -> term / function_call
Rule 28    expression -> term
Rule 29    term -> factor
Rule 30    factor -> NUMBER
Rule 31    factor -> NAME
Rule 32    factor -> ( expression )

Terminals, with rules where they appear

(                    : 8 19 32
)                    : 8 19 32
*                    : 24 26
+                    : 20 22
-                    : 21 23
/                    : 25 27
;                    : 2 4 7 10 13
=                    : 5 18
LET                  : 17
NAME                 : 5 8 17 18 19 31
NUMBER               : 30
error                : 
{                    : 9 10 11
}                    : 9 10 11

Nonterminals, with rules where they appear

block                : 8
expression           : 5 14 18 20 21 22 23 32
factor               : 24 25 29
function             : 6 7
function_call        : 22 23 26 27
functions            : 1 2 7
glob_variable        : 3 4
glob_variables       : 2 4
program              : 0
statement            : 12 13
statements           : 9 10 13
term                 : 20 21 24 25 26 27 28
var_assign           : 16
var_declare          : 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . functions
    (2) program -> . glob_variables ; functions
    (6) functions -> . function
    (7) functions -> . functions ; function
    (3) glob_variables -> . glob_variable
    (4) glob_variables -> . glob_variables ; glob_variable
    (8) function -> . NAME ( ) block
    (5) glob_variable -> . NAME = expression

    NAME            shift and go to state 6

    program                        shift and go to state 1
    functions                      shift and go to state 2
    glob_variables                 shift and go to state 3
    function                       shift and go to state 4
    glob_variable                  shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> functions .
    (7) functions -> functions . ; function

    $end            reduce using rule 1 (program -> functions .)
    ;               shift and go to state 7


state 3

    (2) program -> glob_variables . ; functions
    (4) glob_variables -> glob_variables . ; glob_variable

    ;               shift and go to state 8


state 4

    (6) functions -> function .

    ;               reduce using rule 6 (functions -> function .)
    $end            reduce using rule 6 (functions -> function .)


state 5

    (3) glob_variables -> glob_variable .

    ;               reduce using rule 3 (glob_variables -> glob_variable .)


state 6

    (8) function -> NAME . ( ) block
    (5) glob_variable -> NAME . = expression

    (               shift and go to state 9
    =               shift and go to state 10


state 7

    (7) functions -> functions ; . function
    (8) function -> . NAME ( ) block

    NAME            shift and go to state 12

    function                       shift and go to state 11

state 8

    (2) program -> glob_variables ; . functions
    (4) glob_variables -> glob_variables ; . glob_variable
    (6) functions -> . function
    (7) functions -> . functions ; function
    (5) glob_variable -> . NAME = expression
    (8) function -> . NAME ( ) block

    NAME            shift and go to state 15

    functions                      shift and go to state 13
    glob_variable                  shift and go to state 14
    function                       shift and go to state 4

state 9

    (8) function -> NAME ( . ) block

    )               shift and go to state 16


state 10

    (5) glob_variable -> NAME = . expression
    (20) expression -> . expression + term
    (21) expression -> . expression - term
    (22) expression -> . expression + function_call
    (23) expression -> . expression - function_call
    (28) expression -> . term
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 18
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 11

    (7) functions -> functions ; function .

    ;               reduce using rule 7 (functions -> functions ; function .)
    $end            reduce using rule 7 (functions -> functions ; function .)


state 12

    (8) function -> NAME . ( ) block

    (               shift and go to state 9


state 13

    (2) program -> glob_variables ; functions .
    (7) functions -> functions . ; function

    $end            reduce using rule 2 (program -> glob_variables ; functions .)
    ;               shift and go to state 7


state 14

    (4) glob_variables -> glob_variables ; glob_variable .

    ;               reduce using rule 4 (glob_variables -> glob_variables ; glob_variable .)


state 15

    (5) glob_variable -> NAME . = expression
    (8) function -> NAME . ( ) block

    =               shift and go to state 10
    (               shift and go to state 9


state 16

    (8) function -> NAME ( ) . block
    (9) block -> . { statements }
    (10) block -> . { statements ; }
    (11) block -> . { }

    {               shift and go to state 24

    block                          shift and go to state 23

state 17

    (31) factor -> NAME .

    *               reduce using rule 31 (factor -> NAME .)
    /               reduce using rule 31 (factor -> NAME .)
    +               reduce using rule 31 (factor -> NAME .)
    -               reduce using rule 31 (factor -> NAME .)
    ;               reduce using rule 31 (factor -> NAME .)
    )               reduce using rule 31 (factor -> NAME .)
    }               reduce using rule 31 (factor -> NAME .)


state 18

    (5) glob_variable -> NAME = expression .
    (20) expression -> expression . + term
    (21) expression -> expression . - term
    (22) expression -> expression . + function_call
    (23) expression -> expression . - function_call

    ;               reduce using rule 5 (glob_variable -> NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 19

    (28) expression -> term .
    (24) term -> term . * factor
    (25) term -> term . / factor
    (26) term -> term . * function_call
    (27) term -> term . / function_call

    +               reduce using rule 28 (expression -> term .)
    -               reduce using rule 28 (expression -> term .)
    ;               reduce using rule 28 (expression -> term .)
    )               reduce using rule 28 (expression -> term .)
    }               reduce using rule 28 (expression -> term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 20

    (29) term -> factor .

    *               reduce using rule 29 (term -> factor .)
    /               reduce using rule 29 (term -> factor .)
    +               reduce using rule 29 (term -> factor .)
    -               reduce using rule 29 (term -> factor .)
    ;               reduce using rule 29 (term -> factor .)
    )               reduce using rule 29 (term -> factor .)
    }               reduce using rule 29 (term -> factor .)


state 21

    (30) factor -> NUMBER .

    *               reduce using rule 30 (factor -> NUMBER .)
    /               reduce using rule 30 (factor -> NUMBER .)
    +               reduce using rule 30 (factor -> NUMBER .)
    -               reduce using rule 30 (factor -> NUMBER .)
    ;               reduce using rule 30 (factor -> NUMBER .)
    )               reduce using rule 30 (factor -> NUMBER .)
    }               reduce using rule 30 (factor -> NUMBER .)


state 22

    (32) factor -> ( . expression )
    (20) expression -> . expression + term
    (21) expression -> . expression - term
    (22) expression -> . expression + function_call
    (23) expression -> . expression - function_call
    (28) expression -> . term
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 29
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 23

    (8) function -> NAME ( ) block .

    ;               reduce using rule 8 (function -> NAME ( ) block .)
    $end            reduce using rule 8 (function -> NAME ( ) block .)


state 24

    (9) block -> { . statements }
    (10) block -> { . statements ; }
    (11) block -> { . }
    (12) statements -> . statement
    (13) statements -> . statements ; statement
    (14) statement -> . expression
    (15) statement -> . var_declare
    (16) statement -> . var_assign
    (20) expression -> . expression + term
    (21) expression -> . expression - term
    (22) expression -> . expression + function_call
    (23) expression -> . expression - function_call
    (28) expression -> . term
    (17) var_declare -> . LET NAME
    (18) var_assign -> . NAME = expression
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    }               shift and go to state 31
    LET             shift and go to state 36
    NAME            shift and go to state 37
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    statements                     shift and go to state 30
    statement                      shift and go to state 32
    expression                     shift and go to state 33
    var_declare                    shift and go to state 34
    var_assign                     shift and go to state 35
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 25

    (20) expression -> expression + . term
    (22) expression -> expression + . function_call
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (19) function_call -> . NAME ( )
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    NAME            shift and go to state 40
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    term                           shift and go to state 38
    function_call                  shift and go to state 39
    factor                         shift and go to state 20

state 26

    (21) expression -> expression - . term
    (23) expression -> expression - . function_call
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (19) function_call -> . NAME ( )
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    NAME            shift and go to state 40
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    term                           shift and go to state 41
    function_call                  shift and go to state 42
    factor                         shift and go to state 20

state 27

    (24) term -> term * . factor
    (26) term -> term * . function_call
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )
    (19) function_call -> . NAME ( )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 45
    (               shift and go to state 22

    factor                         shift and go to state 43
    function_call                  shift and go to state 44

state 28

    (25) term -> term / . factor
    (27) term -> term / . function_call
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )
    (19) function_call -> . NAME ( )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 45
    (               shift and go to state 22

    factor                         shift and go to state 46
    function_call                  shift and go to state 47

state 29

    (32) factor -> ( expression . )
    (20) expression -> expression . + term
    (21) expression -> expression . - term
    (22) expression -> expression . + function_call
    (23) expression -> expression . - function_call

    )               shift and go to state 48
    +               shift and go to state 25
    -               shift and go to state 26


state 30

    (9) block -> { statements . }
    (10) block -> { statements . ; }
    (13) statements -> statements . ; statement

    }               shift and go to state 49
    ;               shift and go to state 50


state 31

    (11) block -> { } .

    ;               reduce using rule 11 (block -> { } .)
    $end            reduce using rule 11 (block -> { } .)


state 32

    (12) statements -> statement .

    }               reduce using rule 12 (statements -> statement .)
    ;               reduce using rule 12 (statements -> statement .)


state 33

    (14) statement -> expression .
    (20) expression -> expression . + term
    (21) expression -> expression . - term
    (22) expression -> expression . + function_call
    (23) expression -> expression . - function_call

    }               reduce using rule 14 (statement -> expression .)
    ;               reduce using rule 14 (statement -> expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 34

    (15) statement -> var_declare .

    }               reduce using rule 15 (statement -> var_declare .)
    ;               reduce using rule 15 (statement -> var_declare .)


state 35

    (16) statement -> var_assign .

    }               reduce using rule 16 (statement -> var_assign .)
    ;               reduce using rule 16 (statement -> var_assign .)


state 36

    (17) var_declare -> LET . NAME

    NAME            shift and go to state 51


state 37

    (18) var_assign -> NAME . = expression
    (31) factor -> NAME .

    =               shift and go to state 52
    *               reduce using rule 31 (factor -> NAME .)
    /               reduce using rule 31 (factor -> NAME .)
    +               reduce using rule 31 (factor -> NAME .)
    -               reduce using rule 31 (factor -> NAME .)
    }               reduce using rule 31 (factor -> NAME .)
    ;               reduce using rule 31 (factor -> NAME .)


state 38

    (20) expression -> expression + term .
    (24) term -> term . * factor
    (25) term -> term . / factor
    (26) term -> term . * function_call
    (27) term -> term . / function_call

    +               reduce using rule 20 (expression -> expression + term .)
    -               reduce using rule 20 (expression -> expression + term .)
    ;               reduce using rule 20 (expression -> expression + term .)
    )               reduce using rule 20 (expression -> expression + term .)
    }               reduce using rule 20 (expression -> expression + term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 39

    (22) expression -> expression + function_call .

    +               reduce using rule 22 (expression -> expression + function_call .)
    -               reduce using rule 22 (expression -> expression + function_call .)
    ;               reduce using rule 22 (expression -> expression + function_call .)
    )               reduce using rule 22 (expression -> expression + function_call .)
    }               reduce using rule 22 (expression -> expression + function_call .)


state 40

    (19) function_call -> NAME . ( )
    (31) factor -> NAME .

    (               shift and go to state 53
    *               reduce using rule 31 (factor -> NAME .)
    /               reduce using rule 31 (factor -> NAME .)
    +               reduce using rule 31 (factor -> NAME .)
    -               reduce using rule 31 (factor -> NAME .)
    ;               reduce using rule 31 (factor -> NAME .)
    )               reduce using rule 31 (factor -> NAME .)
    }               reduce using rule 31 (factor -> NAME .)


state 41

    (21) expression -> expression - term .
    (24) term -> term . * factor
    (25) term -> term . / factor
    (26) term -> term . * function_call
    (27) term -> term . / function_call

    +               reduce using rule 21 (expression -> expression - term .)
    -               reduce using rule 21 (expression -> expression - term .)
    ;               reduce using rule 21 (expression -> expression - term .)
    )               reduce using rule 21 (expression -> expression - term .)
    }               reduce using rule 21 (expression -> expression - term .)
    *               shift and go to state 27
    /               shift and go to state 28


state 42

    (23) expression -> expression - function_call .

    +               reduce using rule 23 (expression -> expression - function_call .)
    -               reduce using rule 23 (expression -> expression - function_call .)
    ;               reduce using rule 23 (expression -> expression - function_call .)
    )               reduce using rule 23 (expression -> expression - function_call .)
    }               reduce using rule 23 (expression -> expression - function_call .)


state 43

    (24) term -> term * factor .

    *               reduce using rule 24 (term -> term * factor .)
    /               reduce using rule 24 (term -> term * factor .)
    +               reduce using rule 24 (term -> term * factor .)
    -               reduce using rule 24 (term -> term * factor .)
    ;               reduce using rule 24 (term -> term * factor .)
    )               reduce using rule 24 (term -> term * factor .)
    }               reduce using rule 24 (term -> term * factor .)


state 44

    (26) term -> term * function_call .

    *               reduce using rule 26 (term -> term * function_call .)
    /               reduce using rule 26 (term -> term * function_call .)
    +               reduce using rule 26 (term -> term * function_call .)
    -               reduce using rule 26 (term -> term * function_call .)
    ;               reduce using rule 26 (term -> term * function_call .)
    )               reduce using rule 26 (term -> term * function_call .)
    }               reduce using rule 26 (term -> term * function_call .)


state 45

    (31) factor -> NAME .
    (19) function_call -> NAME . ( )

    *               reduce using rule 31 (factor -> NAME .)
    /               reduce using rule 31 (factor -> NAME .)
    +               reduce using rule 31 (factor -> NAME .)
    -               reduce using rule 31 (factor -> NAME .)
    ;               reduce using rule 31 (factor -> NAME .)
    )               reduce using rule 31 (factor -> NAME .)
    }               reduce using rule 31 (factor -> NAME .)
    (               shift and go to state 53


state 46

    (25) term -> term / factor .

    *               reduce using rule 25 (term -> term / factor .)
    /               reduce using rule 25 (term -> term / factor .)
    +               reduce using rule 25 (term -> term / factor .)
    -               reduce using rule 25 (term -> term / factor .)
    ;               reduce using rule 25 (term -> term / factor .)
    )               reduce using rule 25 (term -> term / factor .)
    }               reduce using rule 25 (term -> term / factor .)


state 47

    (27) term -> term / function_call .

    *               reduce using rule 27 (term -> term / function_call .)
    /               reduce using rule 27 (term -> term / function_call .)
    +               reduce using rule 27 (term -> term / function_call .)
    -               reduce using rule 27 (term -> term / function_call .)
    ;               reduce using rule 27 (term -> term / function_call .)
    )               reduce using rule 27 (term -> term / function_call .)
    }               reduce using rule 27 (term -> term / function_call .)


state 48

    (32) factor -> ( expression ) .

    *               reduce using rule 32 (factor -> ( expression ) .)
    /               reduce using rule 32 (factor -> ( expression ) .)
    +               reduce using rule 32 (factor -> ( expression ) .)
    -               reduce using rule 32 (factor -> ( expression ) .)
    ;               reduce using rule 32 (factor -> ( expression ) .)
    )               reduce using rule 32 (factor -> ( expression ) .)
    }               reduce using rule 32 (factor -> ( expression ) .)


state 49

    (9) block -> { statements } .

    ;               reduce using rule 9 (block -> { statements } .)
    $end            reduce using rule 9 (block -> { statements } .)


state 50

    (10) block -> { statements ; . }
    (13) statements -> statements ; . statement
    (14) statement -> . expression
    (15) statement -> . var_declare
    (16) statement -> . var_assign
    (20) expression -> . expression + term
    (21) expression -> . expression - term
    (22) expression -> . expression + function_call
    (23) expression -> . expression - function_call
    (28) expression -> . term
    (17) var_declare -> . LET NAME
    (18) var_assign -> . NAME = expression
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    }               shift and go to state 54
    LET             shift and go to state 36
    NAME            shift and go to state 37
    NUMBER          shift and go to state 21
    (               shift and go to state 22

    statement                      shift and go to state 55
    expression                     shift and go to state 33
    var_declare                    shift and go to state 34
    var_assign                     shift and go to state 35
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 51

    (17) var_declare -> LET NAME .

    }               reduce using rule 17 (var_declare -> LET NAME .)
    ;               reduce using rule 17 (var_declare -> LET NAME .)


state 52

    (18) var_assign -> NAME = . expression
    (20) expression -> . expression + term
    (21) expression -> . expression - term
    (22) expression -> . expression + function_call
    (23) expression -> . expression - function_call
    (28) expression -> . term
    (24) term -> . term * factor
    (25) term -> . term / factor
    (26) term -> . term * function_call
    (27) term -> . term / function_call
    (29) term -> . factor
    (30) factor -> . NUMBER
    (31) factor -> . NAME
    (32) factor -> . ( expression )

    NUMBER          shift and go to state 21
    NAME            shift and go to state 17
    (               shift and go to state 22

    expression                     shift and go to state 56
    term                           shift and go to state 19
    factor                         shift and go to state 20

state 53

    (19) function_call -> NAME ( . )

    )               shift and go to state 57


state 54

    (10) block -> { statements ; } .

    ;               reduce using rule 10 (block -> { statements ; } .)
    $end            reduce using rule 10 (block -> { statements ; } .)


state 55

    (13) statements -> statements ; statement .

    }               reduce using rule 13 (statements -> statements ; statement .)
    ;               reduce using rule 13 (statements -> statements ; statement .)


state 56

    (18) var_assign -> NAME = expression .
    (20) expression -> expression . + term
    (21) expression -> expression . - term
    (22) expression -> expression . + function_call
    (23) expression -> expression . - function_call

    }               reduce using rule 18 (var_assign -> NAME = expression .)
    ;               reduce using rule 18 (var_assign -> NAME = expression .)
    +               shift and go to state 25
    -               shift and go to state 26


state 57

    (19) function_call -> NAME ( ) .

    +               reduce using rule 19 (function_call -> NAME ( ) .)
    -               reduce using rule 19 (function_call -> NAME ( ) .)
    ;               reduce using rule 19 (function_call -> NAME ( ) .)
    )               reduce using rule 19 (function_call -> NAME ( ) .)
    }               reduce using rule 19 (function_call -> NAME ( ) .)
    *               reduce using rule 19 (function_call -> NAME ( ) .)
    /               reduce using rule 19 (function_call -> NAME ( ) .)

